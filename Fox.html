<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Quantum Fox: Endless Runner</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.1/tween.umd.js"></script>
<style>
body {
    margin:0;
    overflow:hidden;
    background:#0d1117;
    color:#f3f4f6;
    font-family:Inter,system-ui,Arial;
}
canvas {
    display:block;
}
#ui-container{
    position:absolute;
    top:0;
    left:0;
    right:0;
    padding:10px 20px;
    z-index:10;
    display:flex;
    justify-content:space-between;
    align-items:center;
    pointer-events:none;
}
.info-box{
    background: rgba(0,0,0,0.7);
    padding:8px 16px;
    border-radius:8px;
    font-size:1.1rem;
    font-weight:700;
    border:2px solid #3b82f6;
    min-width:140px;
    text-align:center;
}
#touch-indicator{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    z-index:10;
    background: rgba(0,0,0,0.7);
    padding:8px 14px;
    border-radius:8px;
    color:#fcd34d;
    border:2px solid #3b82f6;
    pointer-events:none;
    font-weight:700;
}
#game-over-screen, #leaderboard-screen{
    position:absolute;
    inset:0;
    display:none;
    z-index:30;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.9);
    color:#f3f4f6;
    flex-direction:column;
    opacity:0;
    transition:opacity .4s;
    text-align:center;
    overflow-y:auto;
    padding:20px;
}
.button-group {
    display:flex;
    gap:15px;
    margin-top:20px;
    pointer-events:auto;
}
.restart-button, .close-button{
    padding:12px 22px;
    border-radius:.5rem;
    font-weight:800;
    border:none;
    cursor:pointer;
    background:#fcd34d;
    color:#111827;
    transition: all 0.2s;
}
.restart-button:hover, .close-button:hover {
    background:#fbbf24;
    transform:translateY(-2px);
}
#initials-form {
    display:none;
    flex-direction:column;
    align-items:center;
    margin:20px 0;
    background: rgba(255,255,255,0.1);
    padding:20px;
    border-radius:12px;
    border:2px solid #fcd34d;
    animation: pulse-border 2s infinite;
}
@keyframes pulse-border {
    0% { border-color:#fcd34d; box-shadow:0 0 0 0 rgba(252,211,77,0.4); }
    70% { border-color:#fcd34d; box-shadow:0 0 0 10px rgba(252,211,77,0); }
    100% { border-color:#fcd34d; box-shadow:0 0 0 0 rgba(252,211,77,0); }
}
#initials-input {
    background:#111827;
    border:2px solid #4b5563;
    color:#10b981;
    font-size:2.2rem;
    text-align:center;
    width:260px;
    border-radius:8px;
    text-transform:uppercase;
    margin-bottom:15px;
    font-family:monospace;
    letter-spacing:0.2em;
}
#initials-input:focus {
    outline:none;
    border-color:#10b981;
}
#submit-score-btn {
    background:#10b981;
    color:#064e3b;
    padding:10px 30px;
    border-radius:6px;
    font-weight:800;
    border:none;
    cursor:pointer;
    font-size:1.2rem;
    transition:all 0.2s;
}
#submit-score-btn:disabled {
    background:#4b5563;
    cursor:not-allowed;
    transform:none;
}
#leaderboard-content {
    width:90%;
    max-width:600px;
    margin-top:20px;
    background:rgba(0,0,0,0.7);
    border-radius:10px;
    padding:20px;
    border:2px solid #10b981;
    max-height:60vh;
    overflow-y:auto;
}
.leaderboard-entry {
    display:flex;
    justify-content:space-between;
    padding:8px 0;
    border-bottom:1px dashed #374151;
    font-size:1.1rem;
}
.leaderboard-entry:last-child {
    border-bottom:none;
}
.leaderboard-entry.header {
    font-weight:800;
    font-size:1.3rem;
    color:#fcd34d;
    border-bottom:2px solid #fcd34d;
    margin-bottom:10px;
}
.leaderboard-entry .rank {
    width:10%;
    text-align:center;
    color:#10b981;
}
.leaderboard-entry .initials {
    width:30%;
    text-align:left;
}
.leaderboard-entry .score {
    width:30%;
    text-align:right;
}
</style>
</head>
<body>
    <div id="ui-container">
        <div id="score-display" class="info-box">Score: 0</div>
        <div id="high-score-display" class="info-box">High Score: 0</div>
        <div class="info-box text-sm">A / D (or Arrows) to Switch Lanes</div>
    </div>
    <div id="touch-indicator">Tap Left / Right to Switch Lanes</div>
    <div id="game-container"></div>
    <div id="game-over-screen">
        <h2 style="font-size:3.25rem; color:#ef4444; margin:0 0 .6rem 0; font-weight:900;">Game Over</h2>
        <p style="font-size:1.25rem; margin:0 0 1rem 0;">Final Distance Run: <span id="final-score" style="color:#fbbf24; font-weight:800;">0</span></p>
        <div id="initials-form">
            <p style="font-size:1.2rem; color:#fcd34d; font-weight:800; margin-bottom:10px;">NEW HIGH SCORE!</p>
            <!-- 5 initials instead of 3 -->
            <input type="text" id="initials-input" maxlength="5" placeholder="_____" autocomplete="off">
            <button id="submit-score-btn">SUBMIT</button>
        </div>
        <div class="button-group">
            <button id="restart-btn" class="restart-button">RESTART</button>
            <button id="leaderboard-btn" class="restart-button">LEADERBOARD</button>
        </div>
        <p style="margin-top:12px; color:#9ca3af; font-size:0.9rem;">User ID: <span id="user-id-display">Anonymous</span></p>
    </div>
    <div id="leaderboard-screen">
        <button id="close-leaderboard" class="close-button" style="position:absolute; top:20px; right:20px; padding:8px 16px; font-size:1.1rem;">âœ• CLOSE</button>
        <h2 style="font-size:3rem; color:#10b981; margin-bottom:20px; font-weight:900;">TOP 100 RUNNERS</h2>
        <div id="leaderboard-content">
            <div class="leaderboard-entry header">
                <span class="rank">#</span>
                <span class="initials">INITIALS</span>
                <span class="score">SCORE</span>
            </div>
            <div id="leaderboard-list">Loading...</div>
        </div>
    </div>
    <script type="module">
        /* FIREBASE SETUP */
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, addDoc, query, orderBy, limit, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const HIGH_SCORE_KEY = 'quantumFoxHighScore';
        let db, auth, user;
        let isFirebaseReady = false;
        window.highScoreValue = 0;
        window.qfoxUserId = 'Anonymous';

        /* Color schemes for floor & fog */
        const colorSchemes = [
            // LEVEL 1 (Score 0-249): Dark Blue/Black
            { floor: new THREE.Color('#1f2937'), fog: new THREE.Color('#111827') }, // 0
            // LEVEL 2 (Score 250-499): Vibrant Red
            { floor: new THREE.Color('#A01010'), fog: new THREE.Color('#FF0000') }, // 1
            // LEVEL 3 (Score 500-749): Bright Green
            { floor: new THREE.Color('#008000'), fog: new THREE.Color('#00FF00') }, // 2
            // LEVEL 4 (Score 750-999): Electric Blue
            { floor: new THREE.Color('#1010A0'), fog: new THREE.Color('#00FFFF') }, // 3
            // LEVEL 5 (Score 1000-1249): Hot Pink/Magenta
            { floor: new THREE.Color('#A010A0'), fog: new THREE.Color('#FF00FF') }, // 4
            // LEVEL 6 (Score 1250+): Orange/Gold
            { floor: new THREE.Color('#B8860B'), fog: new THREE.Color('#FF8C00') }, // 5
        ];
        let currentColorIndex = 0;

        /* Reverse color schemes for the trail (opposite of floor progression) */
        const reverseColorSchemes = [...colorSchemes].slice().reverse();

        const firebaseConfig = {
            apiKey: "AIzaSyBgfoQLeOOqbKBuM69SO88jhCpfwrz_koo",
            authDomain: "qfox-29287.firebaseapp.com",
            projectId: "qfox-29287",
            storageBucket: "qfox-29287.appspot.com",
            messagingSenderId: "778217166086",
            appId: "1:778217166086:web:1480312c499fdec6aafa87",
            measurementId: "G-VGEY7GV2QD"
        };

        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                await signInAnonymously(auth);

                onAuthStateChanged(auth, (currentUser) => {
                    if (currentUser) {
                        user = currentUser;
                        window.qfoxUserId = user.uid.substring(0, 8);
                        const uidEl = document.getElementById('user-id-display');
                        if (uidEl) uidEl.textContent = window.qfoxUserId;
                        isFirebaseReady = true;
                        loadHighScore();
                    } else {
                        isFirebaseReady = false;
                    }
                });
            } catch (error) {
                console.error("Firebase init error:", error);
            }
        }

        async function loadHighScore() {
            try {
                const localScore = localStorage.getItem(HIGH_SCORE_KEY);
                if (localScore !== null) {
                    window.highScoreValue = parseInt(localScore, 10) || 0;
                    const hEl = document.getElementById('high-score-display');
                    if (hEl) hEl.textContent = `High Score: ${window.highScoreValue}`;
                }
            } catch (e) {}

            if (!isFirebaseReady || !user) return;

            try {
                const scoreDocRef = doc(db, 'users', user.uid);
                const docSnap = await getDoc(scoreDocRef);
                if (docSnap.exists()) {
                    const firebaseScore = docSnap.data().highScore || 0;
                    if (firebaseScore > window.highScoreValue) {
                        window.highScoreValue = firebaseScore;
                        const hEl = document.getElementById('high-score-display');
                        if (hEl) hEl.textContent = `High Score: ${window.highScoreValue}`;
                        try {
                            localStorage.setItem(HIGH_SCORE_KEY, window.highScoreValue.toString());
                        } catch (e) {}
                    }
                }
            } catch (error) {
                console.error("Load score error:", error);
            }
        }

        window.handleGameOver = async function(finalScore) {
            if (finalScore > window.highScoreValue) {
                window.highScoreValue = finalScore;
                const hEl = document.getElementById('high-score-display');
                if (hEl) hEl.textContent = `High Score: ${window.highScoreValue}`;
                try {
                    localStorage.setItem(HIGH_SCORE_KEY, finalScore.toString());
                } catch (e) {}

                if (isFirebaseReady && user) {
                    try {
                        const scoreDocRef = doc(db, 'users', user.uid);
                        await setDoc(scoreDocRef, { highScore: finalScore, timestamp: serverTimestamp() }, { merge: true });
                    } catch (e) {
                        console.error("Save error:", e);
                    }
                }
            }

            const form = document.getElementById('initials-form');
            if (form) form.style.display = 'none';

            if (isFirebaseReady && user) {
                try {
                    const leaderboardRef = collection(db, 'leaderboard');
                    const lowScoreQuery = query(leaderboardRef, orderBy('score', 'desc'), limit(1000));
                    const querySnapshot = await getDocs(lowScoreQuery);

                    let lowestTopScore = 0;
                    if (!querySnapshot.empty) {
                        const docs = querySnapshot.docs;
                        lowestTopScore = docs[docs.length - 1].data().score || 0;
                    }

                    if (finalScore > lowestTopScore || querySnapshot.size < 1000) {
                        showInitialsInput(finalScore);
                    }
                } catch (error) {
                    console.error("Leaderboard check failed:", error);
                }
            }
        }

        function showInitialsInput(score) {
            const form = document.getElementById('initials-form');
            const input = document.getElementById('initials-input');
            const btn = document.getElementById('submit-score-btn');

            if (!form || !input || !btn) return;

            form.style.display = 'flex';
            input.value = '';
            try {
                input.focus();
            } catch(e){}
            btn.textContent = "SUBMIT";
            btn.disabled = false;
            form.dataset.score = score;
        }

        document.getElementById('submit-score-btn').addEventListener('click', async () => {
            const form = document.getElementById('initials-form');
            const input = document.getElementById('initials-input');
            const btn = document.getElementById('submit-score-btn');
            if (!form || !input || !btn) return;

            // 5-letter initials max
            let initials = input.value.toUpperCase().replace(/[^A-Z]/g, '').slice(0, 5);
            if (!initials) initials = "AAAAA";
            const score = parseInt(form.dataset.score || '0');

            btn.textContent = "SAVING...";
            btn.disabled = true;

            if (isFirebaseReady && user) {
                try {
                    const leaderboardRef = collection(db, 'leaderboard');
                    await addDoc(leaderboardRef, {
                        score: score,
                        initials: initials,
                        uid: user.uid,
                        timestamp: serverTimestamp()
                    });

                    btn.textContent = "SAVED!";
                    setTimeout(() => {
                        if (form) form.style.display = 'none';
                        window.showLeaderboard();
                    }, 800);
                } catch (e) {
                    console.error("Submit error:", e);
                    btn.textContent = "ERROR";
                    setTimeout(() => {
                        btn.disabled = false;
                        btn.textContent = "RETRY";
                    }, 2000);
                }
            } else {
                // Offline fallback
                btn.textContent = "OFFLINE";
                setTimeout(()=>{
                    if (form) form.style.display = 'none';
                    window.showLeaderboard();
                }, 700);
            }
        });

        document.getElementById('initials-input').addEventListener('input', (e) => {
            // 5 letters max, uppercase
            e.target.value = e.target.value.toUpperCase().replace(/[^A-Z]/g, '').slice(0, 5);
        });

        window.showLeaderboard = async function() {
            const screen = document.getElementById('leaderboard-screen');
            const list = document.getElementById('leaderboard-list');

            if (!screen || !list) return;

            screen.style.display = 'flex';
            requestAnimationFrame(()=> screen.style.opacity = 1);

            list.innerHTML = '<div style="text-align:center; padding:20px;">Loading...</div>';

            if (!isFirebaseReady) {
                list.innerHTML = 'Firebase not ready.';
                return;
            }

            try {
                const leaderboardRef = collection(db, 'leaderboard');
                const q = query(leaderboardRef, orderBy('score', 'desc'), limit(100));
                const snapshot = await getDocs(q);

                if (snapshot.empty) {
                    list.innerHTML = 'Be the first to post a score!';
                    return;
                }

                let html = '';
                snapshot.docs.forEach((docSnap, index) => {
                    const data = docSnap.data();
                    const rank = index + 1;
                    const initials = data.initials || '???';
                    const scoreVal = data.score || 0;
                    const isMe = (user && data.uid === user.uid) ? 'color:#fcd34d; font-weight:bold;' : '';

                    html += `<div class="leaderboard-entry" style="${isMe}">
                        <span class="rank">${rank}</span>
                        <span class="initials">${initials}</span>
                        <span class="score">${scoreVal.toLocaleString()}</span>
                    </div>`;
                });

                list.innerHTML = html;
            } catch (error) {
                console.error("Leaderboard error:", error);
                list.innerHTML = `Error: ${error.message}`;
            }
        }

        initFirebase();

        const FOX_HEAD_URL = 'head.png';
        const OBSTACLE_URL = 'orb.png';
        const HALO_URL = 'halo.png';
        const FLOOR_IMAGE_URL= 'floor.png';
        const BACKGROUND_VIDEO_URL = 'background.mp4';
        const MUSIC_URL = 'music.wav';

        let bgm = null;

        function initializeMusic() {
            bgm = new Audio(MUSIC_URL);
            bgm.loop = true;
            bgm.volume = 0.7;
        }

        /* GLOBALS */
        let scene, camera, renderer;
        let foxPlayer = null;
        let floorTexture = null;
        let floorMesh = null;
        let score = 0;
        let gameActive = false;
        let lanePositions = [-3.5, 0, 3.5];
        let currentLane = 1;
        let obstacles = [];
        let obstacleSpawnTimer = 0;
        let gameSpeed = 0.25;
        const BASE_GAME_SPEED = 0.25;
        const SPEED_INCREASE_RATE = 0.0006;
        let runningTime = 0;
        const FOX_BASE_HEIGHT = 1.2;
        let lastTime = performance.now();
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS;
        let firstRun = true; // only first start can be from any key/tap

        const container = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');
        const textureLoader = new THREE.TextureLoader();

        /* TRAIL GLOBALS */
        let trailInitialized = false;
        let trailPoints = [];
        let trailGeometry = null;
        let trailMesh = null;

        const TRAIL_SEGMENTS    = 40;
        const TRAIL_BASE_WIDTH  = 1.6;
        const TRAIL_MIN_WIDTH   = 0.12;
        const TRAIL_SMOOTH      = 0.28;
        const TRAIL_Z_OFFSET    = 1.3;   // positive; we subtract this to push trail BEHIND fox
        const TRAIL_Y_OFFSET    = 0.4;   // lift ribbon slightly above floor
        const TRAIL_LENGTH      = 18.0;  // how far the tail stretches behind the fox

        function setupVideoBackground(){
            if (!scene) return;
            try {
                const vid = document.createElement('video');
                vid.src = BACKGROUND_VIDEO_URL;
                vid.loop = true;
                vid.muted = true;
                vid.playsInline = true;
                vid.play().catch(()=>{});

                const vtex = new THREE.VideoTexture(vid);
                vtex.minFilter = THREE.LinearFilter;
                vtex.magFilter = THREE.LinearFilter;
                scene.background = vtex;
            } catch (e) {
                console.warn('Video background failed:', e);
            }
        }

        /* CREATE FOX */
        function createFox(){
            const geo = new THREE.PlaneGeometry(1.8, 1.8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent:true });
            foxPlayer = new THREE.Mesh(geo, mat);

            textureLoader.load(FOX_HEAD_URL, (tex)=>{
                tex.encoding = THREE.sRGBEncoding;
                foxPlayer.material = new THREE.MeshBasicMaterial({
                    map: tex,
                    transparent: true,
                    side: THREE.FrontSide
                });
                foxPlayer.material.needsUpdate = true;
            });

            foxPlayer.position.set(lanePositions[currentLane], FOX_BASE_HEIGHT, 5);
            foxPlayer.renderOrder = 2; // draw fox on top of trail
            scene.add(foxPlayer);
        }

        /* CREATE TRACK */
        function createTrack(){
            const trackWidth = 18;
            const trackLength = 600;
            const floorGeo = new THREE.PlaneGeometry(trackWidth, trackLength, 1, 1);

            const tex = textureLoader.load(FLOOR_IMAGE_URL, t => {
                t.wrapS = THREE.RepeatWrapping;
                t.wrapT = THREE.RepeatWrapping;
                t.repeat.set(4, 60);
                t.encoding = THREE.sRGBEncoding;
            });

            const floorMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            floorMesh = new THREE.Mesh(floorGeo, floorMat);
            floorMesh.rotation.x = -Math.PI/2;
            floorMesh.position.set(0, 0, 0);
            scene.add(floorMesh);
            floorTexture = tex;
        }

        /* RIBBON TRAIL INIT */
        function initRibbonTrail() {
            if (trailInitialized || !foxPlayer || !scene) return;
            trailInitialized = true;

            trailPoints = [];
            const startPos = foxPlayer.position.clone();
            startPos.y += TRAIL_Y_OFFSET;
            for (let i = 0; i < TRAIL_SEGMENTS; i++) {
                trailPoints.push(startPos.clone());
            }

            const positionArray = new Float32Array(TRAIL_SEGMENTS * 2 * 3);
            const colorArray    = new Float32Array(TRAIL_SEGMENTS * 2 * 3);

            trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            trailGeometry.setAttribute('color',    new THREE.BufferAttribute(colorArray, 3));

            const indices = [];
            for (let i = 0; i < TRAIL_SEGMENTS - 1; i++) {
                const a = i * 2;
                const b = a + 1;
                const c = a + 2;
                const d = a + 3;
                indices.push(a, b, c, b, d, c);
            }
            trailGeometry.setIndex(indices);
            trailGeometry.computeBoundingSphere();

            const trailMaterial = new THREE.MeshBasicMaterial({
                vertexColors: true,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });

            trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
            trailMesh.renderOrder = 0; // behind fox and obstacles
            scene.add(trailMesh);
        }

        /* RIBBON TRAIL UPDATE */
        function updateRibbonTrail(deltaMultiplier) {
            if (!trailInitialized || !trailGeometry || !trailMesh || !foxPlayer) return;

            // head position (fox head) with Y offset
            const headPos = foxPlayer.position.clone();
            headPos.y += TRAIL_Y_OFFSET;

            // insert head at front of list
            trailPoints.unshift(headPos);
            if (trailPoints.length > TRAIL_SEGMENTS) {
                trailPoints.pop();
            }

            // smooth the curve so it bends nicely when fox changes lanes
            for (let i = 1; i < trailPoints.length; i++) {
                trailPoints[i].lerp(trailPoints[i - 1], TRAIL_SMOOTH);
            }

            const positions = trailGeometry.attributes.position.array;
            const colors    = trailGeometry.attributes.color.array;

            const numColors = colorSchemes.length;
            const floorPhase = score / 250;              // how far along the normal floor cycle we are
            const trailPhase = (floorPhase + 1.0) % numColors; // shift by 1 so trail is "opposite" phase
            const baseIndex = Math.floor(trailPhase) % numColors;
            const nextIndex = (baseIndex + 1) % numColors;
            const phaseT    = trailPhase - Math.floor(trailPhase);

            // base color pair for head from reversed schemes (opposite direction to floor)
            const baseColA = reverseColorSchemes[baseIndex].floor.clone();
            const baseColB = reverseColorSchemes[nextIndex].floor.clone();
            const headColor = baseColA.clone().lerp(baseColB, phaseT);

            for (let i = 0; i < TRAIL_SEGMENTS - 1; i++) {
                const tSeg = i / (TRAIL_SEGMENTS - 1); // 0 at head, 1 at tail

                const pCurr = trailPoints[i];
                const pNext = trailPoints[i + 1] || pCurr;

                // Direction along trail
                const dir = new THREE.Vector3().subVectors(pNext, pCurr);
                const laneDir = new THREE.Vector3(0, 0, 1); // forward along +Z
                let side = new THREE.Vector3().crossVectors(laneDir, dir);
                if (side.lengthSq() < 1e-6) {
                    side.set(1, 0, 0); // fallback if fox is going straight
                } else {
                    side.normalize();
                }

                // taper width toward tail
                const width = THREE.MathUtils.lerp(TRAIL_BASE_WIDTH, TRAIL_MIN_WIDTH, tSeg);
                const halfWidth = width * 0.5;
                const offset = side.clone().multiplyScalar(halfWidth);

                const leftPos  = pCurr.clone().add(offset);
                const rightPos = pCurr.clone().sub(offset);

                // push the whole ribbon behind the fox and stretch the tail farther back
                const stretch = TRAIL_LENGTH * tSeg;
                leftPos.z  -= (TRAIL_Z_OFFSET + stretch);
                rightPos.z -= (TRAIL_Z_OFFSET + stretch);

                const vi = i * 2;

                positions[vi * 3 + 0] = leftPos.x;
                positions[vi * 3 + 1] = leftPos.y;
                positions[vi * 3 + 2] = leftPos.z;

                positions[(vi + 1) * 3 + 0] = rightPos.x;
                positions[(vi + 1) * 3 + 1] = rightPos.y;
                positions[(vi + 1) * 3 + 2] = rightPos.z;

                // smooth color transition along trail, cycling opposite to floor
                const colorIndexFloat = (1.0 - tSeg) * (numColors - 1);
                const colorIndex = Math.floor(colorIndexFloat);
                const colorT = colorIndexFloat - colorIndex;
                const idxA = THREE.MathUtils.clamp(colorIndex, 0, numColors - 1);
                const idxB = THREE.MathUtils.clamp(idxA + 1, 0, numColors - 1);

                const colA = reverseColorSchemes[idxA].floor.clone();
                const colB = reverseColorSchemes[idxB].floor.clone();
                const segColor = colA.lerp(colB, colorT);

                // fade brightness toward tail so it doesn't look like a solid bar
                const fadeFactor = THREE.MathUtils.lerp(1.0, 0.08, tSeg);
                const r = segColor.r * fadeFactor;
                const g = segColor.g * fadeFactor;
                const b = segColor.b * fadeFactor;

                colors[vi * 3 + 0] = r;
                colors[vi * 3 + 1] = g;
                colors[vi * 3 + 2] = b;

                colors[(vi + 1) * 3 + 0] = r;
                colors[(vi + 1) * 3 + 1] = g;
                colors[(vi + 1) * 3 + 2] = b;
            }

            // copy last segment positions/colors to close the strip
            const lastIndex = (TRAIL_SEGMENTS - 1) * 2;
            const prevIndex = (TRAIL_SEGMENTS - 2) * 2;

            positions[lastIndex * 3 + 0]     = positions[prevIndex * 3 + 0];
            positions[lastIndex * 3 + 1]     = positions[prevIndex * 3 + 1];
            positions[lastIndex * 3 + 2]     = positions[prevIndex * 3 + 2];
            positions[(lastIndex + 1) * 3 + 0] = positions[(prevIndex + 1) * 3 + 0];
            positions[(lastIndex + 1) * 3 + 1] = positions[(prevIndex + 1) * 3 + 1];
            positions[(lastIndex + 1) * 3 + 2] = positions[(prevIndex + 1) * 3 + 2];

            colors[lastIndex * 3 + 0]     = colors[prevIndex * 3 + 0];
            colors[lastIndex * 3 + 1]     = colors[prevIndex * 3 + 1];
            colors[lastIndex * 3 + 2]     = colors[prevIndex * 3 + 2];
            colors[(lastIndex + 1) * 3 + 0] = colors[(prevIndex + 1) * 3 + 0];
            colors[(lastIndex + 1) * 3 + 1] = colors[(prevIndex + 1) * 3 + 1];
            colors[(lastIndex + 1) * 3 + 2] = colors[(prevIndex + 1) * 3 + 2];

            trailGeometry.attributes.position.needsUpdate = true;
            trailGeometry.attributes.color.needsUpdate = true;
            if (trailGeometry.boundingSphere) trailGeometry.boundingSphere = null;
            trailGeometry.computeBoundingSphere();
        }

        function createObstacle(laneIndex) {
            if (!scene) return;

            const laneX = lanePositions[laneIndex];
            const startZ = -120;
            const size = 2.6; // height
            const haloSize = 3.0;

            const orbWidthRatio = 1.5;

            // Halo
            const haloGeo = new THREE.PlaneGeometry(haloSize, haloSize);
            const haloMat = new THREE.MeshBasicMaterial({
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                opacity: 0.7
            });

            const halo = new THREE.Mesh(haloGeo, haloMat);
            halo.position.set(laneX, 1.35, startZ - 0.2);
            halo.userData.billboard = true;

            textureLoader.load(HALO_URL, tex => {
                tex.encoding = THREE.sRGBEncoding;
                halo.material.map = tex;
                halo.material.needsUpdate = true;
            }, undefined, (err) => {
                console.warn('Halo texture failed to load:', err);
            });

            halo.renderOrder = 1;
            scene.add(halo);

            // Orb
            const orbGeo = new THREE.PlaneGeometry(size * orbWidthRatio, size);
            const orbMat = new THREE.MeshBasicMaterial({
                color:0xffffff,
                transparent:true,
                side: THREE.DoubleSide
            });

            const orb = new THREE.Mesh(orbGeo, orbMat);
            orb.position.set(laneX, 1.35, startZ - 0.2);
            orb.userData.lane = laneIndex;
            orb.userData.billboard = true;
            orb.userData.halo = halo;

            textureLoader.load(OBSTACLE_URL, tex => {
                tex.encoding = THREE.sRGBEncoding;
                orb.material.map = tex;
                tex.minFilter = THREE.LinearMipMapLinearFilter;
                tex.magFilter = THREE.LinearFilter;
                orb.material.needsUpdate = true;
            }, undefined, (err) => {
                console.warn('Orb texture failed to load:', err);
            });

            orb.renderOrder = 2;
            obstacles.push(orb);
            scene.add(orb);
        }

        /* GAME CONTROL */
        function startGame(){
            if (!scene || !renderer || !camera) {
                init();
            }

            if (bgm && bgm.paused) {
                bgm.play().catch(error => {
                    console.warn("Audio playback failed (usually a mobile browser restriction):", error.message);
                });
            }

            // after the very first successful start, we no longer allow any-key restarts
            if (firstRun) firstRun = false;

            gameActive = true;
            score = 0;
            gameSpeed = BASE_GAME_SPEED;
            currentLane = 1;

            if (foxPlayer) foxPlayer.position.x = lanePositions[currentLane];

            obstacles.forEach(o=>{
                try {
                    scene.remove(o);
                    if (o.userData.halo) {
                        scene.remove(o.userData.halo);
                    }
                } catch(e){}
            });
            obstacles = [];
            obstacleSpawnTimer = 0;

            const scoreEl = document.getElementById('score-display');
            if (scoreEl) scoreEl.textContent = `Score: ${score}`;

            if (gameOverScreen) {
                gameOverScreen.style.display = 'none';
                gameOverScreen.style.opacity = 0;
            }

            const lb = document.getElementById('leaderboard-screen');
            if (lb) lb.style.display = 'none';

            const initialsForm = document.getElementById('initials-form');
            if (initialsForm) initialsForm.style.display = 'none';
        }

        /* MOVE FOX */
        function moveFox(newLane){
            // no starting the game from lane changes anymore
            if (!gameActive) return;
            if (!foxPlayer) return;
            if (newLane < 0 || newLane > 2) return;
            if (newLane === currentLane) return;

            currentLane = newLane;
            const targetX = lanePositions[currentLane];

            TWEEN.removeAll();
            new TWEEN.Tween(foxPlayer.position)
                .to({ x: targetX }, 150)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
        }

        /* UPDATE OBSTACLES */
        function updateObstacles(deltaMultiplier){
            if (!foxPlayer) return;

            gameSpeed += SPEED_INCREASE_RATE * deltaMultiplier;

            for (let i = obstacles.length - 1; i >= 0; i--){
                const obs = obstacles[i];
                obs.position.z += gameSpeed * deltaMultiplier;

                // Update halo position
                if (obs.userData.halo) {
                    obs.userData.halo.position.x = obs.position.x;
                    obs.userData.halo.position.z = obs.position.z - 0.2;
                }

                const foxZ = foxPlayer.position.z;
                const obsZ = obs.position.z;
                const collisionRange = 0.9;

                if (obsZ >= foxZ - collisionRange && obsZ <= foxZ + collisionRange) {
                    if (obs.userData.lane === currentLane) {
                        const foxX = foxPlayer.position.x;
                        const obsX = obs.position.x;
                        const lateralRange = 0.9;
                        if (Math.abs(foxX - obsX) < lateralRange) {
                            doGameOver();
                            return;
                        }
                    }
                }

                if (obsZ > foxZ + 2 && !obs.userData.scored) {
                    obs.userData.scored = true;
                    score += 10;
                    const scoreEl = document.getElementById('score-display');
                    if (scoreEl) scoreEl.textContent = `Score: ${score}`;
                }

                if (obsZ > 80) {
                    try {
                        scene.remove(obs);
                        if (obs.userData.halo) {
                            scene.remove(obs.userData.halo);
                        }
                    } catch(e){}
                    obstacles.splice(i,1);
                }
            }

            obstacleSpawnTimer++;
            const spawnRate = Math.max(18, 70 - Math.floor((gameSpeed - BASE_GAME_SPEED) * 140));

            if (obstacleSpawnTimer >= spawnRate) {
                createObstacle(Math.floor(Math.random()*3));
                obstacleSpawnTimer = 0;
            }
        }

        /* GAME OVER */
        function doGameOver(){
            if (!gameActive) return;

            gameActive = false;
            if (bgm) bgm.pause();

            finalScoreEl.textContent = score;
            if (gameOverScreen) {
                gameOverScreen.style.display = 'flex';
            }

            if (typeof window.handleGameOver === 'function') {
                window.handleGameOver(score);
            }

            new TWEEN.Tween({o:0}).to({o:1}, 450).onUpdate(obj=>{
                if (gameOverScreen) gameOverScreen.style.opacity = obj.o;
            }).start();

            // After game over, keys/taps will NOT restart the game.
            // Player must click the RESTART button.
        }

        /* INPUT HANDLING */
        function onKeyDown(e){
            const leaderboardScreen = document.getElementById('leaderboard-screen');
            if (leaderboardScreen && leaderboardScreen.style.display === 'flex') {
                if (e.code === 'Escape' || e.code === 'KeyL') {
                    leaderboardScreen.style.opacity = 0;
                    setTimeout(()=> leaderboardScreen.style.display = 'none', 250);
                }
                return;
            }

            if (e.target && e.target.tagName === 'INPUT') return;

            // If game isn't active and this is the very first run, ANY key can start it.
            if (!gameActive) {
                if (firstRun) {
                    startGame();
                }
                // after first run, ignore keys while gameInactive; restart must use button
                return;
            }

            // In-game controls only if gameActive
            if (e.code === 'KeyA' || e.code === 'ArrowLeft') moveFox(currentLane - 1);
            if (e.code === 'KeyD' || e.code === 'ArrowRight') moveFox(currentLane + 1);
        }

        function onTouchEnd(e){
            if (!e.changedTouches || e.changedTouches.length === 0) return;

            const touchX = e.changedTouches[0].clientX;
            const screenWidth = window.innerWidth;

            if (!gameActive) {
                // Touch start only allowed on very first run
                if (firstRun) {
                    startGame();
                }
                return;
            }

            if (touchX < screenWidth / 2) {
                moveFox(currentLane - 1);
            } else {
                moveFox(currentLane + 1);
            }
        }

        /* INIT + ANIMATE */
        let hasInited = false;
        function init(){
            if (hasInited) return;
            hasInited = true;

            scene = new THREE.Scene();

            const initialFogColor = colorSchemes[0].fog;
            scene.fog = new THREE.Fog(initialFogColor, 40, 150);

            setupVideoBackground();

            camera = new THREE.PerspectiveCamera(72, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3.5, 10);
            camera.lookAt(0, 1, 0);

            renderer = new THREE.WebGLRenderer({ antialias:true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio || 1);
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 20));
            const spot = new THREE.SpotLight(0xffffff, 20, 50, Math.PI/6, 0.3);
            spot.position.set(0, 10, 10);
            scene.add(spot);

            createFox();
            createTrack();

            // delay a bit so fox is in the scene before creating the ribbon
            setTimeout(() => {
                if (!trailInitialized) initRibbonTrail();
            }, 50);

            window.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('touchend', onTouchEnd, {passive:true});

            const restartBtn = document.getElementById('restart-btn');
            if (restartBtn) restartBtn.addEventListener('click', () => {
                // restart is ONLY allowed via this button
                startGame();
            });
            const leaderboardBtn = document.getElementById('leaderboard-btn');
            if (leaderboardBtn) leaderboardBtn.addEventListener('click', () => window.showLeaderboard());
            const closeLb = document.getElementById('close-leaderboard');
            if (closeLb) closeLb.addEventListener('click', () => {
                const lb = document.getElementById('leaderboard-screen');
                if (lb) {
                    lb.style.opacity = 0;
                    setTimeout(()=> lb.style.display = 'none', 300);
                }
            });
        }

        function onWindowResize(){
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(){
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            const deltaMultiplier = deltaTime / FRAME_TIME;

            TWEEN.update();

            if (gameActive) {
                updateObstacles(deltaMultiplier);
                runningTime += 0.11 * deltaMultiplier;

                if (foxPlayer) foxPlayer.position.y = FOX_BASE_HEIGHT + Math.sin(runningTime * 5) * 0.1;

                if (floorTexture) {
                    floorTexture.offset.y += gameSpeed * 0.02 * deltaMultiplier;
                }

                updateFloorAndBackground();

                // Update the ribbon trail while fox is running
                updateRibbonTrail(deltaMultiplier);

                if (camera) {
                    for (let obs of obstacles) {
                        if (obs.userData && obs.userData.billboard && obs.lookAt) {
                            obs.lookAt(camera.position);
                        }
                        if (obs.userData && obs.userData.halo && obs.userData.halo.lookAt) {
                            obs.userData.halo.lookAt(camera.position);
                        }
                    }
                }
            }

            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        function updateFloorAndBackground() {
            const numColors = colorSchemes.length;
            let levelIndex = Math.floor(score / 250) % numColors;
            const nextIndex = (levelIndex + 1) % numColors;
            const t = (score % 250) / 250;

            const currentFloorColor = colorSchemes[levelIndex].floor;
            const nextFloorColor = colorSchemes[nextIndex].floor;
            const interpolatedFloorColor = currentFloorColor.clone().lerp(nextFloorColor, t);

            if (floorMesh && floorMesh.material) {
                floorMesh.material.color = interpolatedFloorColor;
                floorMesh.material.needsUpdate = true;
            }

            const currentFogColor = colorSchemes[levelIndex].fog;
            const nextFogColor = colorSchemes[nextIndex].fog;
            const interpolatedFogColor = currentFogColor.clone().lerp(nextFogColor, t);

            if (scene.fog) {
                scene.fog.color = interpolatedFogColor;
            }
        }

        window.addEventListener('load', () => {
            initializeMusic();
            init();
            animate();
        });
    </script>
</body>
</html>
