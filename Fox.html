<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quantum Fox: Endless Runner</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/23.1.1/tween.umd.js"></script>

  <style>
    body { margin:0; overflow:hidden; background:#0d1117; color:#f3f4f6; font-family:Inter,system-ui,Arial; }
    canvas { display:block; }
    #ui-container{
      position:absolute; top:0; left:0; right:0; padding:10px 20px; z-index:10;
      display:flex; justify-content:space-between; align-items:center; pointer-events:none;
    }
    .info-box{
      background: rgba(0,0,0,0.7); padding:8px 16px; border-radius:8px; font-size:1.1rem; font-weight:700;
      border:2px solid #3b82f6; min-width:140px; text-align:center;
    }
    #touch-indicator{
      position:absolute; bottom:20px; left:50%; transform:translateX(-50%); z-index:10;
      background: rgba(0,0,0,0.7); padding:8px 14px; border-radius:8px; color:#fcd34d; border:2px solid #3b82f6;
      pointer-events:none; font-weight:700;
    }
    #game-over-screen{
      position:absolute; inset:0; display:none; z-index:30; align-items:center; justify-content:center;
      background: rgba(0,0,0,0.9); color:#f3f4f6; flex-direction:column; opacity:0; transition:opacity .4s;
      text-align:center;
    }
    .restart-button{
      margin-top:20px; padding:12px 22px; border-radius:.5rem; font-weight:800; border:none; cursor:pointer;
      background:#fcd34d; color:#111827; pointer-events:auto;
    }
  </style>
</head>
<body>
  <div id="ui-container">
    <div id="score-display" class="info-box">Score: 0</div>
    <div id="high-score-display" class="info-box">High Score: 0</div>
    <div class="info-box text-sm">A / D (or Arrows) to Switch Lanes</div>
  </div>

  <div id="touch-indicator">Swipe Left / Right to Switch Lanes</div>
  <div id="game-container"></div>

  <div id="game-over-screen">
    <h2 style="font-size:3.25rem; color:#ef4444; margin:0 0 .6rem 0; font-weight:900;">STATE COLLAPSE</h2>
    <p style="font-size:1.25rem; margin:0 0 1rem 0;">Final Distance Run: <span id="final-score" style="color:#fbbf24; font-weight:800;">0</span></p>
    <button class="restart-button" onclick="startGame()">RESTART</button>
    <p style="margin-top:12px; color:#9ca3af;">User ID: <span id="user-id-display">Anonymous</span></p>
  </div>

<script>
/* ---------------------------
   ASSET NAMES (confirmed)
----------------------------*/
const FOX_HEAD_URL   = 'head.png';
const OBSTACLE_URL   = 'orb.png';
const FLOOR_IMAGE_URL= 'floor.png';
const BACKGROUND_VIDEO_URL = 'background.mp4';
const MUSIC_URL      = 'music.wav';

/* ---------------------------
   MUSIC (loop, user interaction safe)
----------------------------*/
let bgm = null;
function initializeMusic() {
  bgm = new Audio(MUSIC_URL);
  bgm.loop = true;
  bgm.volume = 0.7;

  const unlock = () => {
    bgm.play().catch(()=>{ /* ignore */ });
    document.removeEventListener('keydown', unlock);
    document.removeEventListener('touchstart', unlock);
  };

  document.addEventListener('keydown', unlock, { passive: true });
  document.addEventListener('touchstart', unlock, { passive: true });
}

/* ---------------------------
   THREE / Game Globals
----------------------------*/
let scene, camera, renderer;
let foxPlayer;
let floorTexture = null;
let floorMesh = null;

let score = 0;
let gameActive = false;
let lanePositions = [-3.5, 0, 3.5];   // widened lanes
let currentLane = 1;

let obstacles = [];
let obstacleSpawnTimer = 0;

let gameSpeed = 0.25;
const BASE_GAME_SPEED = 0.25;
const SPEED_INCREASE_RATE = 0.0006;

let runningTime = 0;
const FOX_BASE_HEIGHT = 1.2;

let touchStartX = 0, touchStartY = 0;
const SWIPE_THRESHOLD = 50;

const container = document.getElementById('game-container');
const scoreDisplay = document.getElementById('score-display');
const gameOverScreen = document.getElementById('game-over-screen');
const finalScoreEl = document.getElementById('final-score');

const textureLoader = new THREE.TextureLoader();

/* ---------------------------
   Background video
----------------------------*/
function setupVideoBackground(){
  const vid = document.createElement('video');
  vid.src = BACKGROUND_VIDEO_URL;
  vid.loop = true;
  vid.muted = true;
  vid.playsInline = true;
  // try play (may be blocked until user interaction)
  vid.play().catch(()=>{ /* fallback solid color if blocked below */ });

  const vtex = new THREE.VideoTexture(vid);
  vtex.minFilter = THREE.LinearFilter;
  vtex.magFilter = THREE.LinearFilter;

  scene.background = vtex;
}

/* ---------------------------
   Create Fox (player)
----------------------------*/
function createFox(){
  const geo = new THREE.PlaneGeometry(1.6, 1.6);
  const mat = new THREE.MeshBasicMaterial({ color: 0xff00ff });

  foxPlayer = new THREE.Mesh(geo, mat);
  textureLoader.load(FOX_HEAD_URL, (tex)=>{
    tex.encoding = THREE.sRGBEncoding;
    foxPlayer.material = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.FrontSide });
    foxPlayer.material.needsUpdate = true;
  }, undefined, (err)=>{ /* keep fallback magenta */ });

  foxPlayer.position.set(lanePositions[currentLane], FOX_BASE_HEIGHT, 5);
  scene.add(foxPlayer);
}

/* ---------------------------
   Create Scrolling Floor (PNG)
   - wider and longer so it extends under the fox
   - oriented so it covers area around player
----------------------------*/
function createTrack(){
  const trackWidth = 18;   // wider to fully cover lanes
  const trackLength = 600; // longer so it extends far past camera

  const floorGeo = new THREE.PlaneGeometry(trackWidth, trackLength, 1, 1);

  // load texture and set repeat and wrapping
  const tex = textureLoader.load(FLOOR_IMAGE_URL, t => {
    t.wrapS = THREE.RepeatWrapping;
    t.wrapT = THREE.RepeatWrapping;
    // repeat.x controls how many times across width, repeat.y along forward length
    t.repeat.set(4, 60);
    t.encoding = THREE.sRGBEncoding;
  }, undefined, (err)=> {
    console.warn('Failed to load floor.png:', err);
  });

  const floorMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
  floorMesh = new THREE.Mesh(floorGeo, floorMat);
  floorMesh.rotation.x = -Math.PI/2;
  // center floor at z = 0 so it extends in front and behind player (player at z=5)
  floorMesh.position.set(0, 0, 0);

  scene.add(floorMesh);
  floorTexture = tex;
}

/* ---------------------------
   Create Obstacles (billboarded planes)
   - uses plane geometry so the orb PNG won't distort
   - always faces camera in animate loop
----------------------------*/
function createObstacle(laneIndex) {
  const laneX = lanePositions[laneIndex];
  const startZ = -300; // spawn far ahead
  const size = 1.6;     // plane size

  const geo = new THREE.PlaneGeometry(size, size);
  const mat = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, side: THREE.DoubleSide });

  const orb = new THREE.Mesh(geo, mat);
  orb.position.set(laneX, 1.35, startZ);
  orb.userData.lane = laneIndex;
  orb.userData.billboard = true;

  // load the PNG as map (no spherical UV distortion)
  textureLoader.load(OBSTACLE_URL, tex => {
    tex.encoding = THREE.sRGBEncoding;
    tex.minFilter = THREE.LinearMipMapLinearFilter;
    tex.magFilter = THREE.LinearFilter;
    orb.material.map = tex;
    orb.material.needsUpdate = true;
  }, undefined, (err)=> {
    console.warn('Failed to load orb.png', err);
  });

  // lower renderOrder if needed to ensure alpha blends nicely
  orb.renderOrder = 1;

  obstacles.push(orb);
  scene.add(orb);
}

/* ---------------------------
   Game control
----------------------------*/
function startGame(){
  gameActive = true;
  score = 0;
  gameSpeed = BASE_GAME_SPEED;
  currentLane = 1;
  if (foxPlayer) foxPlayer.position.x = lanePositions[currentLane];

  // clear obstacles
  obstacles.forEach(o=>scene.remove(o));
  obstacles = [];
  obstacleSpawnTimer = 0;

  scoreDisplay.textContent = `Score: ${score}`;
  gameOverScreen.style.display = 'none';
  gameOverScreen.style.opacity = 0;
}

function moveFox(newLane){
  if (!gameActive) return;
  if (newLane < 0 || newLane > 2) return;
  if (newLane === currentLane) return;

  currentLane = newLane;
  const targetX = lanePositions[currentLane];

  new TWEEN.Tween(foxPlayer.position)
    .to({ x: targetX }, 150)
    .easing(TWEEN.Easing.Quadratic.Out)
    .start();
}

function updateObstacles(){
  // speed ramp
  gameSpeed += SPEED_INCREASE_RATE;

  for (let i = obstacles.length - 1; i >= 0; i--){
    const obs = obstacles[i];
    obs.position.z += gameSpeed;

    // billboard facing: handled in animate()

    // collision: when obs passes near fox Z ~= 5-6
    if (obs.position.z > 4.8 && obs.position.z < 6.2) {
      if (obs.userData.lane === currentLane) {
        doGameOver();
        return;
      }
    }

    // remove obstacles that passed far behind camera
    if (obs.position.z > 80) {
      scene.remove(obs);
      obstacles.splice(i,1);
      score += 10;
      scoreDisplay.textContent = `Score: ${score}`;
    }
  }

  obstacleSpawnTimer++;
  // spawn frequency scales with speed
  const spawnRate = Math.max(18, 70 - Math.floor((gameSpeed - BASE_GAME_SPEED) * 140));
  if (obstacleSpawnTimer >= spawnRate) {
    createObstacle(Math.floor(Math.random()*3));
    obstacleSpawnTimer = 0;
  }
}

function doGameOver(){
  gameActive = false;
  finalScoreEl.textContent = score;
  gameOverScreen.style.display = 'flex';

  new TWEEN.Tween({o:0}).to({o:1}, 450).onUpdate(obj=>{
    gameOverScreen.style.opacity = obj.o;
  }).start();
}

/* ---------------------------
   Input handling
----------------------------*/
function onKeyDown(e){
  if (!gameActive) {
    if (e.code === 'KeyR') startGame();
    return;
  }
  if (e.code === 'KeyA' || e.code === 'ArrowLeft') moveFox(currentLane - 1);
  if (e.code === 'KeyD' || e.code === 'ArrowRight') moveFox(currentLane + 1);
}

function onTouchStart(e){
  if (!e.touches || e.touches.length === 0) return;
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
}

function onTouchEnd(e){
  if (!e.changedTouches || e.changedTouches.length === 0) return;
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > SWIPE_THRESHOLD) {
    if (!gameActive) { startGame(); return; }
    if (dx > 0) moveFox(currentLane + 1);
    else moveFox(currentLane - 1);
  }
}

/* ---------------------------
   Init + Animate
----------------------------*/
function init(){
  scene = new THREE.Scene();
  setupVideoBackground();

  camera = new THREE.PerspectiveCamera(72, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 3.5, 10);
  camera.lookAt(0, 1, 0);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  container.appendChild(renderer.domElement);

  // light (simple)
  scene.add(new THREE.AmbientLight(0xffffff, 1.8));
  const spot = new THREE.SpotLight(0xffffff, 3, 50, Math.PI/6, 0.3);
  spot.position.set(0, 10, 10);
  scene.add(spot);

  createFox();
  createTrack();

  // input
  window.addEventListener('keydown', onKeyDown, false);
  window.addEventListener('resize', onWindowResize, false);
  document.addEventListener('touchstart', onTouchStart, {passive:true});
  document.addEventListener('touchend', onTouchEnd, {passive:true});

  // start
  startGame();
}

function onWindowResize(){
  if (!camera || !renderer) return;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
  requestAnimationFrame(animate);
  TWEEN.update();

  if (gameActive) {
    updateObstacles();

    // fox bob
    runningTime += 0.11;
    foxPlayer.position.y = FOX_BASE_HEIGHT + Math.sin(runningTime * 5) * 0.1;

    // scroll the floor texture in the correct direction
    if (floorTexture) {
      // + direction moves texture "towards" camera to simulate forward movement.
      floorTexture.offset.y += gameSpeed * 0.05;
    }

    // billboard all orbs to face camera (avoid flipping on X)
    for (let obs of obstacles) {
      if (obs.userData && obs.userData.billboard) {
        // Make plane face camera: set quaternion to camera but keep vertical up (optional)
        // Simpler: lookAt camera position but keep same Y orientation to avoid tilt:
        obs.lookAt(camera.position);
        // If you want to avoid tilting (so they always remain upright), you can:
        // const camPos = camera.position.clone(); camPos.y = obs.position.y; obs.lookAt(camPos);
      }
    }
  }

  renderer.render(scene, camera);
}

/* ---------------------------
   Start everything
----------------------------*/
window.onload = () => {
  initializeMusic();
  init();
  animate();
};
</script>
</body>
</html>
